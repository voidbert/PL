\documentclass[12pt, a4paper]{article}

\usepackage[portuguese]{babel}
\usepackage{caption}
\usepackage{float}
\usepackage[a4paper, margin=2cm]{geometry}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{setspace}
\usepackage[x11names]{xcolor}

\chardef\_=`_

\lstdefinestyle{codestyle}{
    language=pascal,
    commentstyle=\color{teal},
    keywordstyle=\color{blue},
    numberstyle=\ttfamily\color{gray},
    stringstyle=\color{red},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=false,
    keepspaces=true,
    numbers=none,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=4,
}

\lstset{
    style=codestyle,
    inputencoding=utf8,
    extendedchars=true
}

\title{
    \vspace*{\fill}
    \textbf{
        \Large Processamento de Linguagens -- Trabalho Prático \\
        \large Compilador de Pascal
    }
}

\author{
    \textbf{Grupo 4} \\
    \begin{tabular}{lc}
        Humberto Gil Azevedo Sampaio Gomes & A104348 \\
        José António Fernandes Alves Lopes & A104541 \\
        José Rodrigo Ferreira Matos        & A100612 \\
    \end{tabular}
}

\date{1 de junho de 2025 \vspace*{\fill}}

\captionsetup{font=onehalfspacing}

\begin{document}

\onehalfspacing
\setlength{\parskip}{\baselineskip}
\setlength{\parindent}{0pt}
\def\arraystretch{1.5}

\thispagestyle{empty}
\begin{center}
    \includegraphics[width=0.25\textwidth]{res/EE-C.pdf}
\end{center}

{\let\newpage\relax\maketitle}
\maketitle
\pagebreak

\begin{abstract}
    Ao longo do último semestre, foi desenvolvido, no âmbito da UC de Processamento de Linguagens,
    um compilador de Pascal Standard \cite{iso} para a \emph{stack machine} EWVM \cite{ewvm}. O
    desenvolvimento dos analisadores léxico, sintático e semântico foi feito em duas fases: em
    primeiro lugar, criaram-se versões mínimas destes componentes, funcionais para um conjunto
    reduzido de programas de exemplo, que depois foram enriquecidas com informação do
    \emph{standard} ISO, garantido que o compilador desenvolvido implementava a linguagem com
    correção. Já a geração de código máquina foi feita diretamente com base na documentação da EWVM.
    Os resultados obtidos, apesar de irem além do que foi pedido pelo enunciado do trabalho prático
    proposto, não cumprem por completo o \emph{standard} ISO.
\end{abstract}

\section{Arquitetura}

\section{Análise Léxica}

\section{Análise Sintática}

\section{Análise Semântica}

\section{Geração de Código}

\section{Otimização de Código}

\section{Erros Descritivos}

Quando um compilador encontra erros no código fonte, deve apresentá-los ao utilizador. A qualidade
destes erros é crucial, devendo ajudar o utilizador a facilmente identificá-los e corrigi-los. No
compilador desenvolvido, procurou-se apresentar os erros léxicos, sintáticos, semânticos, e de
geração de código de modo a providenciar a melhor experiência possível ao utilizador.

Durante a análise léxica, o \emph{lexer} apresenta ao utilizador sequências de caracteres que não
foram reconhecidas, ao contrário de um erro por caractere, como era feito nas aulas práticas da UC.
Deste modo, caso o código fonte contenha vários caracteres inválidos em sequência, o utilizador não
se deparará com dezenas de erros. Ademais, o analisador léxico é capaz de ignorar estas sequências
inválidas, e prosseguir com a análise léxica. Abaixo, apresenta-se um exemplo deste erro:

\lstset{
    language={},
    keywordstyle=\color{red},
    morekeywords={error},
    literate=
        {~}{{{\color{red}\~{}}}}1
        {^}{{{\color{red}\^{}}}}1
        {ã}{{\~{a}}}1
        {ç}{{\c{c}}}1
}

\begin{lstlisting}

<stdin>:3:10: error: Lexer failed to reconize the following characters
     3 |     iteração = 0;
                  ^~
\end{lstlisting}

Como se pode observar, os erros são formatos para que seja possível ao utilizador ver a mensagem de
erro, a sua localização no código, e o código que causou o erro. Esta formatação foi inspirada na
formatação utilizada pelas versões mais recentes do GCC \cite{gcc-errors}.

Em relação à análise sintática, quando um erro é detetado, o autómato LALR é inspecionado para
informar o utilizador que, apesar de um lexema de um dado tipo ter sido encontrado, o autómato
esperava outros tipos de lexema:

\begin{lstlisting}

<stdin>:3:17: error: Unexpected token: 'begin'. Expecting: '(', ';'
     3 | procedure hello begin
                         ^~~~~
\end{lstlisting}

Também foram adicionadas regras à gramática para reconhecer erros frequentes, cujas ações semânticas
apresentam mensagens de erro com sugestões ao utilizador de como pode corrigir o seu código:

\begin{lstlisting}

<stdin>:5:7: error: Did you mean to use ':='?
     5 |     x = 0;
               ^
\end{lstlisting}

Infelizmente, quando um lexema inesperado é encontrado, a análise do autómato para determinar os
lexemas possíveis na posição do erro também será influenciada por estas regras de erro, e a lista
de lexemas esperados não estará completamente correta. No entanto, na prática, esta lista é mais
do que suficiente para o utilizador rapidamente se aperceber que, por exemplo, se esqueceu de um
ponto e vírgula. No entanto, esta falta de controlo sobre o autómato de \emph{parsing} ajudou à
compreensão do motivo pelo qual vários compiladores utilizam \emph{parsers} recursivos descendentes
escritos à mão, em vez de geradores de \emph{parsers}. \cite{compilers-handwritten-parser}

Em relação à recuperação de erros, esta é muito limitada. Visto que a análise semântica é feita em
simultâneo com a análise sintática, um erro de sintaxe que, por exemplo, faça com que uma constante,
variável, \ldots, não seja declarada, fará surgir erros em cascata em todo o código que usa essa
constante / variável / \ldots. Para os evitar, a recuperação de erros apenas é possível com erros
mínimos.

{\color{red} TODO - mais informação sobre recuperação de erros}

Em relação a erros semânticos, estes são muito fáceis de apresentar. Como a análise semântica é
feita em ações semânticas, é trivial, com recurso à função \texttt{lexspan}, saber a localização de
cada erro. No entanto, mesmo com o \emph{tracking} ativado, esta função não aparenta estar a ter o
comportamento correto, visto que devolve comprimentos incorretos para símbolos não terminais, o que
pode ser um possível \emph{bug} do \texttt{ply}. Por este motivo, as linhas vermelhas a indicar a
localização de um erro podem estar incorretas em algumas mensagens de erro específicas. Por exemplo,
na mensagem de erro abaixo, devido a esta limitação, o erro foi colocado na palavra reservada
\texttt{IF}, e não na expressão errada:

\begin{lstlisting}

<stdin>:4:5: error: Expression in if-statement is not boolean
     4 |     if 123 + 456 then
             ^~
\end{lstlisting}

A um nível semântico, também foram implementados diversos avisos, que não impedem a compilação, mas
que avisam o utilizador que pode ter cometido um erro indesejado. Segue-se o exemplo de um destes
avisos:

\lstset{
    keywordstyle=\color{Gold2},
    morekeywords={warning},
    literate=
        {~}{{{\color{Gold2}\~{}}}}1
        {^}{{{\color{Gold2}\^{}}}}1
        {ã}{{\~{a}}}1
        {ç}{{\c{c}}}1
}

\begin{lstlisting}

<stdin>:9:19: warning: Shadowing object with name 'bin'
     9 | function BinToInt(bin: string): integer;
                           ^~~
\end{lstlisting}

Durante a geração de código EWVM, alguns avisos também podem ocorrer. Estes devem-se a limitações da
EWVM, que não permite a representação da totalidade do \emph{standard} Pascal. Segue-se o exemplo de
um destes avisos:

\begin{lstlisting}

warning: Double quotes in string 'Hello, "quoted world"' will be removed in
         EWVM output
\end{lstlisting}

Como se pode observar, durante a geração de código, já não há informação da posição de cada
estrutura no código, pelo que não é possível apresentar a localização exata deste aviso.

\section{Testes Realizados}

\section{Resultados Obtidos}

O compilador desenvolvido, tal como requisitado, é capaz de transformar programas Pascal
\emph{standard} em \emph{assembly} EWVM.

De um ponto de vista funcional, o compilador suporta várias construções da linguagem, desde as
consideradas obrigatórias pelo enunciado (declaração de variáveis, expressões aritméticas e comandos
de controlo de fluxo), como também outras sugeridas pelo enunciado (procedimentos e funções).
Ademais, foram também implementadas outras partes do \emph{standard}, como declaração de
\emph{labels}, constantes e tipos de dados (\emph{aliases}, tipos enumerados, \emph{ranges} e até
\emph{arrays} multidimensionais). Ademais, foi implementado o tipo \texttt{string} e a função
\texttt{length} que, apesar de não estarem incluídos no \emph{standard} ISO, são necessários para a
compilação dos programas de exemplo fornecidos pela equipa docente.

No entanto, há várias funcionalidades de Pascal que são implementadas de uma forma limitada, e
outras que, devido a falta de tempo, não foram de todo implementadas. Uma das principais limitações
na implementação existente do compilador é a impossibilidade da definição de procedimentos e funções
recursivos: permiti-lo implicaria mudanças substanciais à implementação da tabela de símbolos, para
ser possível, por exemplo, distinguir entre uma chamada recursiva de uma função e a definição do
valor a devolver. Destaca-se também a impossibilidade de passar \emph{arrays} como argumentos de
funções e procedimentos. Em relação às funcionalidades por implementar, destacam-se os vários tipos
de dados por suportar (apontadores, \emph{records}, \emph{sets} e \emph{files}), bem como os
operadores a si associados.

Em relação à correção do compilador, este foi capaz de compilar corretamente os programas de teste
fornecidos pela equipa docente, bem como outros testes construídos pelo grupo de trabalho, que
testam funcionalidades específicas e complexas, onde podem residir falhas. A passagem destes testes
não prova a correção completa do compilador, mas ajuda a aumentar a confiança que se tem no mesmo.

Quanto à estrutura do compilador, considera-se que o código desenvolvido é modular e facilmente
extensível. A título de exemplo, devido à estrutura intermédia emitida pelo \emph{parser}, mais rica
em informação do que uma AST vulgar, foi trivial a implementação de geração de código para a EWVM,
bem como também seria a adição de outros \emph{backends}, como, por exemplo, para \emph{output} de
código C \cite{c} ou LLVM \cite{llvm}. Ademais, o código Python escrito foi todo tipado, e estes
tipos verificados com o \texttt{mypy} \cite{mypy}. A informação de tipos constitui uma grande fonte
de documentação que, juntamente com nomes de variáveis descritivos, permite uma compreensão fácil
do significado de diversos métodos, de campos de estruturas de dados, \emph{etc.}

Por último, o compilador desenvolvido é bastante eficiente, na medida que foi arquitetado para
minimizar o número de iterações pelas várias estruturas com que lida (código fonte, grafo
intermédio, e representação intermédia do \emph{asssembly} EWVM). O compilador também é capaz de
gerar código eficiente, sendo usadas técnicas de manipulação de AST e de otimização \emph{peephole}
para melhorar o desempenho do código. Note-se que as otimizações feitas são bastante limitadas,
visto que otimizações mais complexas exigiriam a construção de grafos de controlo de fluxo, e o
desenvolvimento de outras representações intermédias, possivelmente da forma
\emph{single static-assignment} (SSA), tal como o LLVM \cite{llvm}.

\section{Conclusão}

Em suma, ao longo do último semestre, foi desenvolvido, no âmbito da UC de Processamento de
Linguagens, um compilador de Pascal Standard \cite{iso} para a \emph{stack machine} EWVM
\cite{ewvm}. Devido a falta de tempo, não foi possível explorar este problema tanto quanto era
inicialmente desejado: no início deste projeto, considerou-se a possibilidade de se suportar o
\emph{standard} ISO completo, bem como mais \emph{backends} além de EWVM. No entanto, aprendeu-se
que a implementação de um compilador não é nada simples: apesar da especificação de Pascal ser
curta e utilizar uma linguagem pouco complexa, ao contrário de outras linguagens, ter o cuidado
de suportar os vários erros e \emph{edge-cases} possíveis consumiu a maior parte do tempo de
desenvolvimento. Ademais, foi necessário garantir que todas as funcionalidades conseguiam coexistir
umas com as outras sem conflitos, garantindo uma geração de \emph{assembly} correta
independentemente do código Pascal escrito. Por último, com o desenvolvimento deste compilador,
percebeu-se o motivo pelo qual as técnicas de otimização são geralmente feitas em representações
intermédias na forma SSA, tendo-se chegado à conclusão de que as otimizações \emph{peephole} e por
manipulação da árvore de sintaxe abstrata são bastante limitadas. Apesar do compilador desenvolvido
não ter atingido os objetivos inicialmente planeados, cumpre os requisitos do enunciado do trabalho
prático e implementa várias outras funcionalidades adicionais, pelo que se considera que este
projeto foi concluído com sucesso.

\begingroup
\section{Bibliografia}
\renewcommand{\section}[2]{}

\begin{thebibliography}{9}
    \bibitem{iso}
        \emph{Information Technology -- Programming Languages -- Pascal}, ISO 7185, 1990. [Online].
        Available: \url{https://archive.org/details/iso-iec-7185-1990-Pascal}
    \bibitem{ewvm}
        S. Rocha, J. Ramalho. ``Virtual Machine EWVM.'' EWVM. Accessed: May 29, 2025. [Online.]
        Available: \url{https://ewvm.epl.di.uminho.pt/}
    \bibitem{gcc-errors}
        Free Software Foundation, ``GCC online documentation''. GCC, the GNU Compiler Collection.
        Accessed: May 31, 2025. [Online.] Available:
        \url{https://gcc.gnu.org/onlinedocs/gcc/Diagnostic-Message-Formatting-Options.html}
    \bibitem{compilers-handwritten-parser}
        P. Eaton, ``Parser generators vs. handwritten parsers: surveying major language
        implementations in 2021.'' Phil Eaton. Accessed: May 31, 2025. [Online.] Available:
        \url{https://notes.eatonphil.com/parser-generators-vs-handwritten-parsers-survey-2021.html}
    \bibitem{c}
        \emph{Information Technology -- Programming Languages -- C}, ISO 9899, 2024. [Online].
        Available: \url{https://www.iso.org/standard/82075.html}
    \bibitem{llvm}
        LLVM-admin team.``The LLVM Compiler Infrastructure.'' LLVM. Accessed: May 29, 2025.
        [Online.] Available: \url{https://llvm.org/}
    \bibitem{mypy}
        The mypy project.``mypy.'' mypy. Accessed: May 29, 2025. [Online.] Available:
        \url{https://mypy-lang.org/}
\end{thebibliography}
\endgroup

\end{document}
